---
layout: post
title: 搭建持续集成的Pipeline
date: 2017-11-09
tags: Kubernetes
---

## 第四式：借助Jenkins，构造持续交付的Pipeline

### 目的：

* 大事化小： 将传统的巨型架构转换成微服务
* 和Jenkins整合，构造持续交付系统
* 构造一个私有的Docker仓库
* 设置持续交付pipeline

### 介绍：

###### Kubernetes的天性就是用来构造微服务架构，但是，大多数老的架构都是庞大的-所有的功能都放在一个应用上，因此这章我们来讨论如何从传统的应用架构转向到微服务架构。但是如果将一个大的应用拆分开，在代码部署上如果手动部署，可能要累死。那么让我们来学习如何构造一个自己的持续交付系统，私有仓库；

#### 从大到小：
![](micro.png)

典型的应用架构都是借助框架MVC(Model-View-Controller)，将每一个功能放在一个单独的二进制文件，比如java的war包； 当然用传统的应用架构也是有好处的，比如说降低了和组件的依赖性，很容易去做部署和测试；

 当然，传统的应用架构也有不好的地方，比如说随着应用功能的越来越多，代码的行数就会越来越多，功能之间的依赖性较大，团队维护起来比较麻烦，代码释放周期也会比较长；
 
 因此，容器和Kubernetes的出现，让构造微服务架构变的越来越简单，越来越灵活，微服务架构的理念非常简单，就是将一个大的部分，拆分成一块一块的功能，每一块提供一个API(RESTful)或其他的网络API调用方式，这样的好处就是每个功能都是相互独立的，那么每块功能都是独立的，代码更新不会产生过多的依赖。这种方式也更加适合敏捷开发思路；
 
>为了能从dockerhub上传和下载镜像，请在hub.docker.com注册一个账号。注意：如果上传自己的景象到Dockerhub，避免携带敏感的信息，因为上传到DockerHub的镜像都是公开的；

### 步骤：
1.  首先我们先构造一个微服务，打包成Docker镜像，然后借助Kubernetes Replication controller和Service组件将其部署到集群当中;

```
# 1. 应用文件
[root@srv-k8s-master1 src]# cat entry.py
from flask imoprt Flask, request

app = Flask(__name__)

@app.route("/")
def hello():
    return "Hello World"

if __name__ = "__main__":
    app.run(host="0.0.0.0")
    
# 2. DockerFile用来构造镜像    
[root@srv-k8s-master1 src]# cat Dockerfile
FROM ubuntu:14.04

# Update Packages
RUN apt-get update -y

# Install Python SetupTolls
RUN apt-get install -y python-setuptools git telnet curl

# Install pip
RUN easy_install pip

# Bundle app source
ADD . /src
WORKIR /src

# Add and install python modules
RUN pip install Flask

# Expose
EXPOSE 5000

# Run
CMD ["python", "entry.py"]

# 3. 构造镜像
[root@srv-k8s-master1 src]# docker build - < Dockerfile
Sending build context to Docker daemon 2.048 kB
Step 1 : FROM ubuntu:14.04
...
...
```


