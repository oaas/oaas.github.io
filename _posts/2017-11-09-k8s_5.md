---
layout: post
title: 搭建持续集成的Pipeline
date: 2017-11-09
tags: Kubernetes
---

## 第四式：借助Jenkins，构造持续交付的Pipeline

### 目的：

* 大事化小： 将传统的巨型架构转换成微服务
* 和Jenkins整合，构造持续交付系统
* 构造一个私有的Docker仓库
* 设置持续交付pipeline

### 介绍：

###### Kubernetes的天性就是用来构造微服务架构，但是，大多数老的架构都是庞大的-所有的功能都放在一个应用上，因此这章我们来讨论如何从传统的应用架构转向到微服务架构。但是如果将一个大的应用拆分开，在代码部署上如果手动部署，可能要累死。那么让我们来学习如何构造一个自己的持续交付系统，私有仓库；

#### 从大到小：
![](https://raw.githubusercontent.com/oaas/kubernetes/master/chapter5/micro.png)

典型的应用架构都是借助框架MVC(Model-View-Controller)，将每一个功能放在一个单独的二进制文件，比如java的war包； 当然用传统的应用架构也是有好处的，比如说降低了和组件的依赖性，很容易去做部署和测试；

 当然，传统的应用架构也有不好的地方，比如说随着应用功能的越来越多，代码的行数就会越来越多，功能之间的依赖性较大，团队维护起来比较麻烦，代码释放周期也会比较长；
 
 因此，容器和Kubernetes的出现，让构造微服务架构变的越来越简单，越来越灵活，微服务架构的理念非常简单，就是将一个大的部分，拆分成一块一块的功能，每一块提供一个API(RESTful)或其他的网络API调用方式，这样的好处就是每个功能都是相互独立的，那么每块功能都是独立的，代码更新不会产生过多的依赖。这种方式也更加适合敏捷开发思路；
 
>为了能从dockerhub上传和下载镜像，请在hub.docker.com注册一个账号。注意：如果上传自己的景象到Dockerhub，避免携带敏感的信息，因为上传到DockerHub的镜像都是公开的；

### 步骤：
1.  首先我们先构造一个微服务，打包成Docker镜像，然后借助Kubernetes Replication controller和Service组件将其部署到集群当中;

```
# 1. 应用文件
[root@srv-k8s-master1 src]# cat entry.py
from flask import Flask, request

app = Flask(__name__)

@app.route("/")
def hello():
    return "Hello World"

@app.route("/power/<int:base>/<inde:index>")
def power(base, index):
    return "%d" %(base ** index)

@app.route("/addition/<int:x>/<int:y>")
def add(x,y):
    return "%d" %(x+y)

@app.route("/substraction/<int:x>/<int:y>")
def substract(x,y):
    return "%d" %(x+y)


if __name__ == "__main__":
    app.run(host="0.0.0.0")
    
# 2. DockerFile用来构造镜像    
[root@srv-k8s-master1 src]# cat Dockerfile
FROM ubuntu:14.04

# Update Packages
RUN apt-get update -y

# Install Python SetupTolls
RUN apt-get install -y python-setuptools git telnet curl

# Install pip
RUN easy_install pip

# Bundle app source
ADD . /src
WORKIR /src

# Add and install python modules
RUN pip install Flask

# Expose
EXPOSE 5000

# Run
CMD ["python", "entry.py"]

# 3. 构造镜像
[root@srv-k8s-master1 src]# docker build -t leejung168/myflask - < Dockerfile
Sending build context to Docker daemon 2.048 kB
......
......
Successfully built 93a60d0bc1b4

＃4. 证实镜像
[root@srv-k8s-master1 src]# docker images
REPOSITORY                                       TAG                 IMAGE ID            CREATED             SIZE
leejung168/myflask                               latest              93a60d0bc1b4        30 minutes ago      284.1 MB

＃ 5. 使用Docker login命令登陆Docker Hub, 注意用DockerID代替邮箱地址作为用户名登录；
[root@srv-k8s-master1 src]# docker login
Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one.
Username: leejung168
Password:
Login Succeeded

＃ 6. 将第三步构造的对象上传到DockerHub中去
[root@srv-k8s-master1 src]# docker push leejung168/myflask
The push refers to a repository [docker.io/leejung168/myflask]
a6e6017a124e: Preparing
395032084629: Preparing
3b5cb70bf5c2: Preparing
843a90470241: Preparing
dbd723878ad8: Pushing [==========================>                        ] 10.98 MB/21.09 MB
......
......
latest: digest: sha256:55286318d7002feda5927cda4f8e5ee0336a3cd8bf32e7c542d1ef69484b1c9f size: 2412

# 7. 此时登录Dockerhub，dashboard上会显示对应的镜像，如下


＃ 8. 我们再来构造一个flask应用，用来做前端页面展示
[root@srv-k8s-master1 src]# cat entry.py
from flask import Flask, request, redirect, render_template
import os
import httplib

app = Flask(__name__)

@app.route("/")
def index():
    return render_template("index.html")

@app.route("/add", methods=['POST'])
def add():
    x = int(request.form['x'])
    y = int(request.form['y'])

    my_calc_host = os.environ['MY_CALC_SERVICE_SERVICE_HOST']
    my_calc_port = os.environ['MY_CALC_SERVICE_SERVICE_PORT']

    client = httplib.HTTPConnection(my_calc_host, my_calc_port)
    client.request("GET", "/addition/%d/%d" % (x, y))
    response = client.getresponse()
    result = response.read()
    return render_template('index.html', add_x=x, add_y=y, add_result=result)

if __name__ == "__main__":
    app.debug = True
    app.run(host="0.0.0.0")
    
# 9. 创建index.html，然后放在templates下
[root@srv-k8s-master1 src]# ls
Dockerfile  entry.py  templates
[root@srv-k8s-master1 src]# cat templates/index.html
<html>
<body>
<div>
    <form method="post" action="/add">
        <input type="text" name="x" size="2"/>
        <input type="text" name="y" size="2"/>
        <input type="submit" value="addition" />
    </form>
    {% if add_result %}
    <p>Answer : {{ add_x }} + {{ add_y }} = {{ add_result }}</p>
    {% endif %}
</div>
</body>
</html>

＃ 10. Dockerfile和之前的一样，不变
[root@srv-k8s-master1 src]# docker build -t leejung168/myfront - < Dockerfile
Sending build context to Docker daemon 2.048 kB
Step 1 : FROM ubuntu:14.04
........
........
Successfully built 93a60d0bc1b4

# 11. 构造完成后，进行上传
[root@srv-k8s-master1 src]# docker push leejung168/myfront
The push refers to a repository [docker.io/leejung168/myfront]
.....
latest: digest: sha256:55286318d7002feda5927cda4f8e5ee0336a3cd8bf32e7c542d1ef69484b1c9f size: 2412

# 12. 此时Dockerhub有两个镜像
```
第七步图片
![](https://raw.githubusercontent.com/oaas/kubernetes/master/chapter5/dockerhub.png)


```
# 13. 构建myflask应用的
[root@srv-k8s-master1 ~]# cat my-calc.yaml
apiVersion: v1
kind: ReplicationController
metadata:
  name: my-calc-rc
spec:
  replicas: 2
  selector:
    app: my-calc
  template:
    metadata:
      labels:
        app: my-calc
    spec:
      containers:
      - name: my-calc
        image: leejung168/myflask
---
apiVersion: v1
kind: Service
metadata:
  name: my-calc-service

spec:
  ports:
    - protocol: TCP
      port: 5000
  type: NodePort
  selector:
    app: my-calc
    
[root@srv-k8s-master1 ~]# kubectl create -f my-calc.yaml
replicationcontroller "my-calc-rc" created
service "my-calc-service" created

＃ 14. 构造WebUI的认证
[root@srv-k8s-master1 ~]# cat my-frontend.yaml
apiVersion: v1
kind: ReplicationController
metadata:
  name: my-frontend-rc
spec:
  replicas: 2
  selector:
    app: my-frontend
  template:
    metadata:
      labels:
        app: my-frontend
    spec:
      containers:
      - name: my-frontend
        images: leejung168/myfront
---
apiVersion: v1
kind: Service
metadata:
  name: my-frontend-service
spec:
  ports:
    - protocol: TCP
      port: 5000
      nodePort: 30080
  type: NodePort
  selector:
    app: my-frontend

[root@srv-k8s-master1 ~]# kubectl create -f my-frontend.yaml

# 15. 访问测试
curl http://$node_ip: 30080    

＃16. 工作原理如下图

```

![](https://raw.githubusercontent.com/oaas/kubernetes/master/chapter5/micros.png)

#### 结论

上个案例中，将一个服务拆分成两个微服务， 如果你想添加额外的微服务，你可以创建另一个镜像，然后接住replication controller和service将其部署在集群当中；
